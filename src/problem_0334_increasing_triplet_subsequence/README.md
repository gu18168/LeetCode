最简单的做法就是 O(N^2) 的方法，每个 index 都作为 start 试一下能不能行，当然这个会超时。

这里比较难解决的问题是，比如已经有 [3, 4] 长度为 2 的递增子序列，此时遇到一个 0，那这个时候是归零重启呢？还是忽略这个 0。

从上面的分岔就能联想到 DP，都试试就知道了呗，然而也会超时。

最后才想到这里是 3 个元素，如果我们已经有了最小值，我们只要知道一个元素后面还有没有更大的，就能立即做出判断。比如上面的例子，如果我们知道后面还有比 4 更大的，那可以忽略 0，如果没有，那就必须从 0 重启了。这就是解题的思路所在。

但是看了题解的贪心算法，如果 third < first 的时候，只替换 first 不替换 second 的做法，真的绝妙啊！